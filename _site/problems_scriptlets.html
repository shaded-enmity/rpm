<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="Rpm : ">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Problems of scriptlets</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/lkardos/rpm">View on GitHub</a>

          <h1 id="project_title">Rpm</h1>
          <h2 id="project_tagline"></h2>
        <div id="menu">
           <ul id="nav">
              <li><a href="index.html">Home</a></li>
              <li><a href="documentation.html">Docs</a></li>
              <li><a href="source.html">Download source</a></li>
              <li><a href="help.html">Getting help</a></li>
              <li><a href="contribute.html">Contribute</a></li>
              <li><a href="software.html">Related Software</a></li>
           </ul>
        </div>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
      <p>One level up: <a href="contribute.html">Contribute</a></p>

<p>Scriptlets are the only possibility to influent files, that cannot be part of the static file list itself. The scriptlet concept provides several types of script types. However these scripts don’t fit the need of the real life packaging. Especially several types of standard scenarions does not have any related RPM script level concept:</p>

<h3 id="database-rebuild">Database rebuild</h3>

<p>This installation concept requires rebuild of certain type of a database from scratch when file is installed or uninstalled. RPM scripts fit very badly to this concept.</p>
<dl>
<dt>Examples:</dt>
<dd>ldconfig, gtk-update-icon-cache, update-mime-database, update-desktop-database</dd>
<dt>Why:</dt>
<dd>There is no concept of scripts called once per transaction or once per installation batch.</dd>
<dt>Work-arounds:</dt>
<dd>External tools (SuSEconfig).</dd>
<dd>Calling script multiple times at cost of &gt;&gt;10000% of performance drop-down.</dd>
<dd>Making installation images. Scriptlets are called by image author instead of installing person.</dd>
<dt>Proposed solution:</dt>
<dd>Introduction of new scriptlets:</dd>
<dd>from uninstalled instance before starting to place new files</dd>
<dd>or</dd>
<dd>from installed instance after removing of replaced files (optional, %posttrans does it)</dd>
<dt>Note:</dt>
<dd>This concept requires a short service drop-out while installing.</dd>
</dl>

<h3 id="registry-which-needs-subscription-and-unsubscription">Registry, which needs subscription and unsubscription</h3>
<p>This installation concept requires registration of each installed file to certain type of a database and deregistration when file is uninstalled. RPM scripts fit very badly to this concept.</p>
<dl>
<dt>Examples:</dt>
<dd>gconf install rules, install-info</dd>
<dt>Why:</dt>
<dd>It is not possible to execute script from uninstalled instance just before starting of upgrade process.</dd> 
<dd>The only script from installed version available after completing update is %posttrans, which was intended for different types of actions.</dd>
<dt>Work-arounds:</dt>
<dd>Three scripts have to be activated. With co-ordination of old and new instance, hiding of files away from RPM sight, it is possible to work-around this problem. The solution is ugly and fragile.</dd>
<dt>Proposed solution:</dt>
<dd>Introduction of new scriptlets:</dd>
<dd>from uninstalled instance before starting to place new files</dd>
<dd>or</dd>
<dd>from installed instance after removing of replaced files (optional, %posttrans does it)</dd>
<dt>Note:</dt>
<dd>This concept requires a short service drop-out while installing.</dd>
</dl>

<h3 id="daemon-restart">Daemon restart</h3>
<p>Daemon should be started on installation, stopped on removal and restarted just once during update.</p>

<p>This problem exhibits combination of “registration/deregistration to database” and “Complex update with package rename or split”.</p>
<dl>
<dt>Examples:</dt>
<dd>All init scripts</dd>
<dt>Why:</dt>
<dd>There is no uninstallation script early enough to stop before removal and it is hard to guess, whether it is update or removal.</dd>
<dt>Work-arounds:</dt>
<dd>Three scripts have to be activated. With co-ordination of old and new instance, it is possible to partially work-around this problem. The solution is ugly and fragile and cannot provide a solution for package rename or split.</dd>
<dt>Proposed solution:</dt>
<dd>More straightforward detection of upgrade. </dd>
<dd>Introduction of new scriptlet from installed instance after removing of replaced files (optional, %posttrans does it)</dd>
</dl>

<h3 id="proposal">Proposal</h3>

<p>Remove the scripts handling special file types (or services) out of the packages containing them and allow the packages that handle the file type (contain the programs to do so) to register a handler that takes care of those files. There are currently two ideas:</p>

<ul>
  <li>File triggers: Add a new flag or tag to register triggers for file patterns. While this is consistent with the current trigger mechanism it makes it hard to really act more intelligent - especially if even the large number of newly started processes is becoming a problem.</li>
  <li>Lua: Extent the rpm lua API to lua scripts have access to the transaction details. Then allow registrating hooks - lua functions that are called from special places in the rpm code - that can check for files needing special treatment in the transaction. As the state of the lua interpreter is maintained over the runtime of rpm it is easy to collect data in one hook (e.g. pkg install and remove) and use it in another (e.g. post trans). The obvious disadvantage is the lua centricity of this solution. </li>
</ul>


      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Rpm maintained by <a href="https://github.com/lkardos">lkardos</a></p>
        <p>Published with <a href="https://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
